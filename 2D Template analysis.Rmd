---
title: "Template for 2D data analysis with INLABru"
author: "J Matthiopoulos (collated from INLABru vignettes)"
date: '2022-05-27'
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. Preparation

## I.1. Load libraries

```{r results="hide",warning=FALSE,message=FALSE}
# Essential
library(inlabru)
library(INLA)
bru_options_set(inla.mode = "experimental")

# Visualisation
library(ggplot2)
library(RColorBrewer)

# Loaded dependencies
#library(sp)
#library(Matrix)
#library(foreach)
#library(parallel)

# Optional
library(mgcv) # For independent model performance comparisons, used as an exact method


```
## I.2. Load data
In the example below, it is assumed that the data reside in a package, such as 'inlabru'. The 'try' option explores the list of available datasets. The second line loads the particular one. Other ways of importing the data, assuming they are not in a package ('?data') with option 'lib.loc' for pathname. 

```{r eval=FALSE}
try(data(package="inlabru"))
data(gorillas, package = "inlabru")
```

## I.3. Ensure data formatting

The overall structure of the data can be explored by 'str()'. The point locations (here, 'nests') need to be a 'SpatialPointsDataFrame'. If the point data are not in this form then, they will need to be converted by providing an appropriate spatial projection ('?SpatialPointsDataFrame').

```{r eval=FALSE}
str(gorillas)
str(gorillas$nests)
myPoints<-gorillas$nests # assign to shorthand
myCovs <- gorillas$gcov # Covariate data
```
If the data set comes with in-built mesh and boundary components, then proceed to I.5, otherwise specify the mesh in the next section. 

```{r eval=FALSE}
str(gorillas$mesh)
str(gorillas$boundary)
myMesh<-gorillas$mesh # assign to shorthand
myBoundary<-gorillas$boundary # assign to shorthand
```
Visualise the factor covariate data (`vegetation` type)

```{r eval=FALSE, warning=FALSE, message=FALSE}
ggplot() +
  gg(myCovs$vegetation) +
  gg(myMesh) +
  gg(myBoundary) +
  gg(myPoints, color = "white", cex = 0.5) +
  coord_equal()
```



# II. GLMs

## II.1 A GLM with a factor covariate only
To construct a model with vegetation type as a fixed effect, we need to tell 'lgcp' how to find the vegetation type at any point in space, and we do this by creating model components with a fixed effect that we call `vegetation` (we could call it anything), as follows:


```{r eval=FALSE, warning=FALSE,message=FALSE}
myFactComp <- coordinates ~ vegetation(myCovs$vegetation, model = "factor_full") - 1
```

Notes:

* We need to tell 'lgcp' that this is a factor fixed effect, which we do 
with `model="factor_full"`, giving one coefficient for each factor level.
* We need to be careful about overparameterisation when using factors.
Unlike regression models like `lm()`, `glm()` or `gam()`, `lgcp()`,
`inlabru` does not automatically remove the first level and absorb it into
an intercept. Instead, we can either use `model="factor_full"` without an intercept,
or `model="factor_contrast"`, which does remove the first level.

```{r eval=FALSE, warning=FALSE,message=FALSE}
myFactCompAlt <- coordinates ~ vegetation(gcov$vegetation, model = "factor_contrast") + Intercept(1)
```
The model can be fitted as follows

```{r eval=FALSE, results='hide',warning=FALSE,message=FALSE,eval=FALSE}
myFactorGLM <- lgcp(myFactComp, myPoints, samplers = myBoundary, domain = list(coordinates = myMesh))
```


Predict the intensity, and plot the median intensity surface. The `predidct` function of `inlabru` takes into its `data` argument a `SpatialPointsDataFrame`, 
a `SpatialPixelsDataFrame` or a `data.frame`. We can use the `inlabru` function `pixels` to generate
a `SpatialPixelsDataFrame` only within the boundary, using its `mask` argument, as shown below.


```{r eval=FALSE, warning=FALSE,message=FALSE}
df <- pixels(myMesh, mask = myBoundary)
int1 <- predict(myFactorGLM, data = df, ~ exp(vegetation))
ggplot() +
  gg(int1) +
  gg(myBoundary, alpha = 0, lwd = 2) +
  gg(myPoints, color = "DarkGreen") +
  coord_equal()
```

The estimated total abundance of points (but not full posterior) can be obtained as follows.The integration `weight` values (the quadrature points) are contained in the `ipoints` output.

```{r eval=FALSE, warning=FALSE,message=FALSE}
ips <- ipoints(myBoundary, myMesh)
Lambda1 <- predict(myFactorGLM, ips, ~ sum(weight * exp(vegetation)))
Lambda1
```
## II.1 A GLM with a continuous covariate only

# III. SPDE models

## III.1. Build the SPDE mesh 

----> HERE ADD MESH-BUILDING PSEUDOCODE

Plot the points (the nests(. (The `ggplot2` function `coord_fixed()` sets the aspect ratio, 
which defaults to 1.)

```{r eval=FALSE, results="hide",warning=FALSE,message=FALSE}
ggplot() +
  gg(myMesh) +
  gg(myPoints) +
  gg(myBoundary) +
  coord_fixed() +
  ggtitle("Points")
```

## III.2. The model

First, specify spatial correlation structure. The following is an example using a Matern correlation structure with a PC prior.

```{r eval=FALSE}
myCorrelation<-inla.spde2.pcmatern(myMesh, prior.range = c(5, 0.01), prior.sigma = c(0.1, 0.01))
  
```

Then, define the model. The model formula requires the explicit name 'coordinates' to recognise the mesh information that it will receive later, but can use the user-defined 'mySmooth()' to specify the spatial error term.  

```{r eval=FALSE}

myModel<-coordinates~mySmooth(coordinates, model=myCorrelation) + Intercept(1)
  
```
The `lcgp` models is fitted as follows:
 

```{r eval=FALSE, warning=FALSE, message=FALSE}

myFit<-lgcp(myModel, data=myPoints, samplers=myBoundary, domain=list(coordinates=myMesh))
  
```
Summary statistics:

```{r eval=FALSE,warning=FALSE,message=FALSE}
summary(myFit)
```

## III.3 Inference 

Plotting fixed effect parameters

```{r eval=FALSE,warning=FALSE,message=FALSE}
plot(myFit, "Intercept")
```

Plotting spatial random effects
Plots of the individual parameters

```{r eval=FALSE,warning=FALSE,message=FALSE}
spde.range <- spde.posterior(myFit, "mySmooth", what = "range")
spde.logvar <- spde.posterior(myFit, "mySmooth", what = "log.variance")
range.plot <- plot(spde.range)
var.plot <- plot(spde.logvar)
multiplot(range.plot, var.plot)
```

Plots of the correlation and covariance functions

```{r eval=FALSE,warning=FALSE,message=FALSE}
corplot <- plot(spde.posterior(myFit, "mySmooth", what = "matern.correlation"))
covplot <- plot(spde.posterior(myFit, "mySmooth", what = "matern.covariance"))
multiplot(covplot, corplot)
```

## III.4 Model predictions

First need to generate the prediction data frame. The 'pixels()' command generates a regular grid of points which can be used for the prediction. This is stored as a spatial data frame in the user-defined 'myPredFrame'. 

```{r eval=FALSE, warning=FALSE, message=FALSE}

myPredFrame<-pixels(myMesh, nx = 50, ny = 50, mask = FALSE)
  
```
To constrain the predictions to a particular region (e.g. the boundary of the mesh), set the mask option in the 'pixels()' command to 'mask=myBoundary'.

Now we can generate the predictions.


```{r eval=FALSE, warning=FALSE, message=FALSE}

myPreds<-predict(myFit, myPredFrame,~ exp(mySmooth + Intercept))
  
```
Note that multiple functions and linear predictors can be predicted simultaneously, under different names.

```{r eval=FALSE, warning=FALSE, message=FALSE}
myPreds<-predict(myFit, myPredFrame,  
                 ~ data.frame(myLambda = exp(mySmooth + Intercept),
                              myLoglambda = mySmooth + Intercept)
                )
  
```

We can visualize multiple aspects of the predictions

Plotting intensity and log-intensity surfaces

```{r eval=FALSE, warning=FALSE, message=FALSE}
pl1 <- ggplot() +
  gg(myPreds$myLambda) +
  gg(myBoundary) +
  ggtitle("LGCP fit to Points", subtitle = "(Response Scale)") +
  coord_fixed()
pl2 <- ggplot() +
  gg(myPreds$myLoglambda) +
  gg(myBoundary) +
  ggtitle("LGCP fit to Points", subtitle = "(Linear Predictor Scale)") +
  coord_fixed()
multiplot(pl1, pl2, cols = 2)
```

Alternatively, plotting maps of median, lower 95% and upper 95% density surfaces as follows (assuming that the predicted intensity is in object `myLambda`).

```{r eval=FALSE,warning=FALSE,message=FALSE,fig.width=9,fig.height=4}
ggplot() +
  gg(cbind(myPreds$myLambda, data.frame(property = "q0.500")), aes(fill = median)) +
  gg(cbind(myPreds$myLambda, data.frame(property = "q0.025")), aes(fill = q0.025)) +
  gg(cbind(myPreds$myLambda, data.frame(property = "q0.975")), aes(fill = q0.975)) +
  coord_equal() +
  facet_wrap(~property)
```


## III.5 Estimating abundance

Estimating abundance uses the `predict` function. As a first step we need an estimate
 for the integrated lambda (denoted 'Lambda' with an upper case L). The integration `weight` values (the quadrature points) are contained in the `ipoints` output. 
 

```{r eval=FALSE,warning=FALSE,message=FALSE,echo=TRUE}
Lambda <- predict(
  myFit,
  ipoints(myBoundary, myMesh),
  ~ sum(weight * exp(mySmooth + Intercept))
)
Lambda
```


Use the median and 95%iles of this to determine interval boundaries for estimating the posterior abundance distribution (prediction, not credible interval).

```{r eval=FALSE,warning=FALSE,message=FALSE,echo=TRUE}
abundance <- predict(
  myFit, ipoints(myBoundary, myMesh),
  ~ data.frame(
    N = 500:800,
    dpois(500:800,
      lambda = sum(weight * exp(mySmooth + Intercept))
    )
  )
)
```

Can get the quantiles of the posterior for abundance via

```{r eval=FALSE, warning=FALSE,message=FALSE,echo=TRUE}
inla.qmarginal(c(0.025, 0.5, 0.975), marginal = list(x = Nest$N, y = Nest$mean))
```
... the mean via
```{r eval=FALSE, warning=FALSE,message=FALSE,echo=TRUE}
inla.emarginal(identity, marginal = list(x = Nest$N, y = Nest$mean))
```
and plot posteriors:
```{r eval=FALSE, results="hide",warning=FALSE,message=FALSE,echo=TRUE}
Nest$plugin_estimate <- dpois(Nest$N, lambda = Lambda$mean)
ggplot(data = Nest) +
  geom_line(aes(x = N, y = mean, colour = "Posterior")) +
  geom_line(aes(x = N, y = plugin_estimate, colour = "Plugin"))
```